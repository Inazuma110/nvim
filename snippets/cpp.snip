snippet	while
abbr	while
	while(${1}) {
		${2:/* code */}
	}


snippet	do while
abbr	do
	do{
		${1}
	} while();

snippet	return
abbr	return
	return ${1};

snippet	cout
abbr	cout
	cout << ${1:/* message */} << endl;

snippet	cin
abbr	cin
	cin >> ${1:/* variable */};

snippet	vector declare
	vector<${1:int}> ${2:v};

snippet	twovec
abbr	twovec dec
	vector<vector<${1:type}>> ${3:vv}(${2:elementNum},vector<$1>(${4}));

snippet	push_back func
abbr	push_back()
	push_back(${1});

snippet	map declare
abbr	map
	map<${1:key}, ${2:value}> ${3:mp};${4}

snippet	printf
abbr	printf
	printf("${1:%d}\n",${2:/*variable*/});

snippet	hudou
abbr	hudou
	cout<<setprecision(15);

snippet	cmp
abbr	cmp
	bool cmp(const Info &a, const Info &b)
	{
		return a.${1:val} < b.$1;${2}
	}

snippet	comb
abbr	comb
	long long comb(int n, int r) {
		if(r > n - r) r = n - r; // because C(n, r) == C(n, n - r)
		long long ans = 1;

		for(int i = 1; i <= r; i++) {
			ans *= n - r + i;
			ans /= i;
		}

		return ans;
	}

snippet	digit_sum
abbr	digit_sum
	ll digitSum(int n)
	{
	  if(n < 10) return n;
	  else return n % 10 + digitSum(n / 10);
	}

snippet	dijkstra
abbr	dijkstra
	struct Graph {
	  vector<vector<int>> cost;
	  vector<bool> visited;
	  vector<int> min_cost;


	  int dijkstra(int start, int goal){
	    min_cost[start] = 0;
	    int now = start;
	    while(true) {
	      if(now == goal) {
	        int result = min_cost[now];
	        visited = vector<bool> (int(cost.size()), false);
	        min_cost = vector<int> (int(cost.size()), INT_MAX);
	        return result;
	      }

	      visited[now] = true;
	      for (int i = 0; i < int(cost.size()); i++) {
	        if(cost[now][i] != -1){
	          min_cost[i] = min(min_cost[i], min_cost[now]+cost[now][i]);
	        }
	      }

	      int min_node_index = -1;
	      int min_node_cost = INT_MAX;
	      for (int i = 0; i < int(cost.size()); i++) {
	        if((min_node_cost > min_cost[i]) && !visited[i]){
	          min_node_index = i;
	          min_node_cost = min_cost[i];
	        }
	      }
	      now = min_node_index;
	    }

	    // error
	    return -1;
	  }
	};

snippet	factoring
abbr	factoring
	vector<pair<ll, int>> factoring(ll a){
	  vector<pair<ll, int>> v;
	  for (int i = 2; i <= a; i++) {
	    if(a % i == 0){
	      int count = 0;
	      while(a % i == 0){
	        count++;
	        a /= i;
	      }
	      v.push_back({i, count});
	    }
	  }
	  return v;
	}

snippet	gcd_lcm
abbr	gcd_lcm
	ll gcd(ll a, ll b)
	{
	  if(b == 0) return a;
	  else return gcd(b, a % b);
	  // return (b == 0) ? a : gcd(b, a % b);
	}

	ll lcm(ll a, ll b)
	{
	  ll g = gcd(a, b);
	  return a / g * b;
	}


snippet	unionfind
abbr	unionfind
	struct UnionFind {
	  // 要素に対応する値は自分の根。根は要素数の-1倍したものを代入する。
	  // 根ならそのグループの要素数(負)が、子であれば親の番号が入る。初期値-1。
	  vector<int> uni;
	  UnionFind(){
	    uni = vector<int>(100100, -1);
	  }

	  // 頂点aの所属するグループを調べる。
	  int root(int a)
	  {
	    // uni[a]が負の値なら親はa自身
	    if (uni[a] < 0) return a;
	    // 正の値であれば、親ルートを調べ戻り値で根に直接つなぐ。
	    else {
	      uni[a] = root(uni[a]);
	      return uni[a];
	      // return uni[a] = root(uni[a]);
	    }
	  }

	  // 頂点aとbをつなぐ、もともと同じグループの場合falseを返す。
	  bool connect(int a, int b)
	  {
	    a = root(a);
	    b = root(b);
	    if (a == b) return false;

	    // aを大きなグループにしたいので、逆であれば入れ替える。
	    if (uni[a] > uni[b])
	    {
	      int hoge = a;
	      a = b;
	      b = hoge;
	    }

	    //aとbを結合し、bをaの親とする。
	    uni[a] += uni[b];
	    uni[b] = a;
	    return true;
	  }

	  //  頂点a, bが同じグループか
	  bool isConnect(int a, int b)
	  {
	    return root(a) == root(b);
	  }

	  // 頂点aを含むグループの頂点数を調べる
	  int size(int a)
	  {
	    return -uni[root(a)];
	  }

	};

snippet	enumeration
abbr	enumeration
	vector<ll> enumeration(ll n){
	  vector<ll> result;
	  for (ll i = 1; i*i <= n; i++) {
	    if(n % i == 0){
	      result.push_back(i);
	      result.push_back(n / i);
	    }
	  }
	  sort(ALL(result));
	  return result;
	}

snippet	logn
abbr	logn
	long double logn(int base, int tv) {
	  return log(tv) / log(base);
	}

snippet	graph
abbr	graph
	struct Graph {
	  vector<vector<int>> cost;
	  vector<bool> visited;
	  vector<int> min_cost;
	  int node_num, edge_num;

	  Graph(int nn, int en) : node_num(nn), edge_num(en){
	    visited = vector<bool> (node_num, false);
	    min_cost = vector<int> (node_num, INT_MAX);
	    cost = vector<vector<int>> (node_num, vector<int> (node_num, -1));
	  }

	  void dijkstra(int start){
	    priority_queue<p, vector<p>, greater<p>> pq;
	    pq.push({0, start});
	    min_cost[start] = 0;
	    while(!pq.empty()) {
	      int now_cost = pq.top().first;
	      int now = pq.top().second;
	      pq.pop();
	      if(min_cost[now] < now_cost) continue;

	      visited[now] = true;
	      for (int i = 0; i < int(cost[now].size()); i++) {
	        if(!visited[now] || (cost[now][i] != -1 && min_cost[i] >= min_cost[now]+cost[now][i])){
	          min_cost[i] = min_cost[now]+cost[now][i];
	          pq.push({min_cost[i], i});
	        }
	      }
	    }

	    init();
	  }

	  void init(){
	    visited = vector<bool> (node_num, false);
	    min_cost = vector<int> (node_num, INT_MAX);
	  }
	};



snippet	tree
abbr	tree
	struct Tree {
	  ll node_num;
	  ll edge_num;
	  ll diameter = -1;
	  ll far_index = -1;
	  vector<vector<ll>> to;
	  vector<bool> visited;
	  vector<int> depth;

	  Tree(ll nn) : node_num(nn){
	    edge_num = node_num - 1;
	    to = vector<vector<ll>> (node_num);
	    visited = vector<bool> (node_num, false);
	    depth = vector<int> (node_num);
	  }


	  pair<ll, ll> get_far(ll from, ll d){
	    visited[from] = true;
	    for(auto a : to[from]){
	      if(!visited[a]){
	        get_far(a, d+1);
	      }
	    }
	    if(diameter < d){
	      diameter = d;
	      far_index = from;
	    }
	    return {far_index, diameter};
	  }

	  ll get_diameter(ll from){
	    pair<ll, ll> i_and_d = get_far(0, 0);
	    init();
	    diameter = get_far(i_and_d.first, 0).second;
	    init();
	    return diameter;
	  }

	  void init(){
	    visited = vector<bool> (node_num, false);
	  }

	  int set_depth(int from, int d){
	    visited[from] = true;
	    for(auto a : to[from]){
	      if(!visited[a]) set_depth(a, d+1);
	    }
	    return depth[from] = d;
	  }
	};


snippet	lcs
abbr	lcs
	int lcs_size(string s1, string s2){
	  int n1 = int(s1.size());
	  int n2 = int(s2.size());
	  for (int i = 1; i <= n1; i++) {
	    for (int j = 1; j <= n2; j++) {
	      if(s1[i-1] == s2[j-1]){
	        dp[i][j] = dp[i-1][j-1] + 1;
	        from[i][j] = 1;
	        continue;
	      }
	      dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
	      from[i][j] = (dp[i][j] == dp[i-1][j]) ? 3 : 2;
	    }
	  }
	  return dp[n1][n2];
	}


	string lcs(string s1, string s2){
	  string res = "";
	  int n1 = int(s1.size());
	  int n2 = int(s2.size());
	  int x = lcs_size(s1, s2);
	  while(x > 0){
	    if(from[n1][n2] == 1){
	      res += s1[n1-1];
	      n1--; n2--; x--;
	    }else if(from[n1][n2] == 2) n2--;
	    else n1--;
	  }

	  reverse(res.begin(), res.end());
	  return res;
	}

snippet	mint
abbr	mint
	struct mint {
	  ll x;
	  mint(ll x=0):x(x%MOD){}
	  mint& operator+=(const mint a) {
	    if ((x += a.x) >= MOD) x -= MOD;
	    return *this;
	  }
	  mint& operator-=(const mint a) {
	    if ((x += MOD-a.x) >= MOD) x -= MOD;
	    return *this;
	  }
	  mint& operator*=(const mint a) {
	    (x *= a.x) %= MOD;
	    return *this;
	  }
	  mint operator+(const mint a) const {
	    mint res(*this);
	    return res+=a;
	  }
	  mint operator-(const mint a) const {
	    mint res(*this);
	    return res-=a;
	  }
	  mint operator*(const mint a) const {
	    mint res(*this);
	    return res*=a;
	  }
	};


snippet	comb_mod
abbr	comb_mod
	const int MAX = 510000;
	ll fac[MAX], finv[MAX], inv[MAX];

	// テーブルを作る前処理
	void comb_init() {
	    fac[0] = fac[1] = 1;
	    finv[0] = finv[1] = 1;
	    inv[1] = 1;
	    for (int i = 2; i < MAX; i++){
	        fac[i] = fac[i - 1] * i % MOD;
	        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;
	        finv[i] = finv[i - 1] * inv[i] % MOD;
	    }
	}

	// 二項係数計算
	ll com(int n, int k){
	    if (n < k) return 0;
	    if (n < 0 || k < 0) return 0;
	    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;
	}
