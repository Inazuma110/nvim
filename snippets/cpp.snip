snippet	while
abbr	while
	while(${1}) {
		${2:/* code */}
	}


snippet	do while
abbr	do
	do{
		${1}
	} while();

snippet	return
abbr	return
	return ${1};

snippet	cout
abbr	cout
	cout << ${1:/* message */} << endl;

snippet	cin
abbr	cin
	cin >> ${1:/* variable */};

snippet	vector declare
	vector<${1:int}> ${2:v};

snippet	twovec
abbr	twovec dec
	vector<vector<${1:type}>> ${3:vv}(${2:elementNum},vector<$1>(${4}));

snippet	push_back func
abbr	push_back()
	push_back(${1});

snippet	map declare
abbr	map
	map<${1:key}, ${2:value}> ${3:mp};${4}

snippet	printf
abbr	printf
	printf("${1:%d}\n",${2:/*variable*/});

snippet	hudou
abbr	hudou
	cout<<setprecision(15);

snippet	cmp
abbr	cmp
	bool cmp(const Info &a, const Info &b)
	{
		return a.${1:val} < b.$1;${2}
	}

snippet	comb
abbr	comb
	long long comb(int n, int r) {
		if(r > n - r) r = n - r; // because C(n, r) == C(n, n - r)
		long long ans = 1;

		for(int i = 1; i <= r; i++) {
			ans *= n - r + i;
			ans /= i;
		}

		return ans;
	}

snippet	digit_sum
abbr	digit_sum
	ll digitSum(int n)
	{
	  if(n < 10) return n;
	  else return n % 10 + digitSum(n / 10);
	}

snippet	dijkstra
abbr	dijkstra
	struct Node {
	  vector<int> to;
	  vector<int> cost;
	  bool done = false;
	  int minCost = INT_MAX;
	};

	int dijkstra(vector<Node> v, int start, int goal){
	  int nodeNum = int(v.size());
	  v[start].minCost = 0;
	  int now = start;
	  while(true) {
	    // printNode(v);
	    v[now].done = true;
	    if(now == goal) return v[now].minCost;
	    int edgeNum = int(v[now].to.size());
	    for (int i = 0; i < edgeNum; i++) {
	      int nextNodeIndex = v[now].to[i];
	      v[nextNodeIndex].minCost =
	        min(v[nextNodeIndex].minCost, v[now].minCost + v[now].cost[i]);
	    }

	    int minNodeIndex = -1;
	    int minNodeCost = INT_MAX;
	    for (int i = 0; i < nodeNum; i++) {
	      if(i == now) continue;
	      if(minNodeCost > v[i].minCost && !v[i].done){
	        minNodeIndex = i;
	        minNodeCost = v[i].minCost;
	      }
	    }
	    now = minNodeIndex;
	  }
	}

snippet	factoring
abbr	factoring
	vector<pair<ll, int>> factoring(ll a){
	  vector<pair<ll, int>> v;
	  for (int i = 2; i <= a; i++) {
	    if(a % i == 0){
	      int count = 0;
	      while(a % i == 0){
	        count++;
	        a /= i;
	      }
	      v.push_back({i, count});
	    }
	  }
	  return v;
	}

snippet	gcd_lcm
abbr	gcd_lcm
	ll gcd(ll a, ll b)
	{
	  if(b == 0) return a;
	  else return gcd(b, a % b);
	  // return (b == 0) ? a : gcd(b, a % b);
	}

	ll lcm(ll a, ll b)
	{
	  ll g = gcd(a, b);
	  return a / g * b;
	}


snippet	unionfind
abbr	unionfind
	struct UnionFind {
	  // 要素に対応する値は自分の根。根は要素数の-1倍したものを代入する。
	  // 根ならそのグループの要素数(負)が、子であれば親の番号が入る。初期値-1。
	  vector<int> uni;
	  UnionFind(){
	    uni = vector<int>(100100, -1);
	  }

	  // 頂点aの所属するグループを調べる。
	  int root(int a)
	  {
	    // uni[a]が負の値なら親はa自身
	    if (uni[a] < 0) return a;
	    // 正の値であれば、親ルートを調べ戻り値で根に直接つなぐ。
	    else {
	      uni[a] = root(uni[a]);
	      return uni[a];
	      // return uni[a] = root(uni[a]);
	    }
	  }

	  // 頂点aとbをつなぐ、もともと同じグループの場合falseを返す。
	  bool connect(int a, int b)
	  {
	    a = root(a);
	    b = root(b);
	    if (a == b) return false;

	    // aを大きなグループにしたいので、逆であれば入れ替える。
	    if (uni[a] > uni[b])
	    {
	      int hoge = a;
	      a = b;
	      b = hoge;
	    }

	    //aとbを結合し、bをaの親とする。
	    uni[a] += uni[b];
	    uni[b] = a;
	    return true;
	  }

	  //  頂点a, bが同じグループか
	  bool isConnect(int a, int b)
	  {
	    return root(a) == root(b);
	  }

	  // 頂点aを含むグループの頂点数を調べる
	  int size(int a)
	  {
	    return -uni[root(a)];
	  }

	};
